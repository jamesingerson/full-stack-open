{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\n\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\nfunction processFragments(ast) {\n  var seenKeys = new Set();\n  var definitions = [];\n  ast.definitions.forEach(function (fragmentDefinition) {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), {\n    definitions: definitions\n  });\n}\n\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function (node) {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(function (key) {\n      var value = node[key];\n\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n  var loc = doc.loc;\n\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables: experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables\n    });\n\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n\n  return docCache.get(cacheKey);\n}\n\nexport function gql(literals) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  var result = literals[0];\n  args.forEach(function (arg, i) {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql: gql,\n  resetCaches: resetCaches,\n  disableFragmentWarnings: disableFragmentWarnings,\n  enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n\n(function (gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\n\ngql[\"default\"] = gql;\nexport default gql;","map":{"version":3,"mappings":"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","names":["__assign","parse","docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","cacheKeyFromLoc","loc","source","body","substring","start","end","processFragments","ast","seenKeys","Set","definitions","forEach","fragmentDefinition","kind","fragmentName","name","value","sourceKey","sourceKeySet","get","has","console","warn","set","add","push","stripLoc","doc","workSet","node","Object","keys","key","startToken","endToken","parseDocument","cacheKey","parsed","allowLegacyFragmentVariables","Error","gql","literals","args","_i","arguments","length","result","arg","i","resetCaches","clear","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","extras","gql_1"],"sources":["C:/Users/jamesi/Desktop/Repos/full-stack-open/part8/library-frontend/node_modules/graphql-tag/lib/index.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n"]},"metadata":{},"sourceType":"module"}