{"ast":null,"code":"import { __assign, __rest as __rest_1, __spreadArray } from \"tslib\";\nimport { __rest } from \"tslib\";\nimport { mergeDeep } from \"../common/mergeDeep.js\";\nexport function concatPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming) {\n      return existing ? __spreadArray(__spreadArray([], existing, true), incoming, true) : incoming;\n    }\n  };\n}\nexport function offsetLimitPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming, _a) {\n      var args = _a.args;\n      var merged = existing ? existing.slice(0) : [];\n\n      if (incoming) {\n        if (args) {\n          var _b = args.offset,\n              offset = _b === void 0 ? 0 : _b;\n\n          for (var i = 0; i < incoming.length; ++i) {\n            merged[offset + i] = incoming[i];\n          }\n        } else {\n          merged.push.apply(merged, incoming);\n        }\n      }\n\n      return merged;\n    }\n  };\n}\nexport function relayStylePagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    read: function (existing, _a) {\n      var canRead = _a.canRead,\n          readField = _a.readField;\n      if (!existing) return existing;\n      var edges = [];\n      var firstEdgeCursor = \"\";\n      var lastEdgeCursor = \"\";\n      existing.edges.forEach(function (edge) {\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n\n          if (edge.cursor) {\n            firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n            lastEdgeCursor = edge.cursor || lastEdgeCursor;\n          }\n        }\n      });\n\n      var _b = existing.pageInfo || {},\n          startCursor = _b.startCursor,\n          endCursor = _b.endCursor;\n\n      return __assign(__assign({}, getExtras(existing)), {\n        edges: edges,\n        pageInfo: __assign(__assign({}, existing.pageInfo), {\n          startCursor: startCursor || firstEdgeCursor,\n          endCursor: endCursor || lastEdgeCursor\n        })\n      });\n    },\n    merge: function (existing, incoming, _a) {\n      var args = _a.args,\n          isReference = _a.isReference,\n          readField = _a.readField;\n\n      if (!existing) {\n        existing = makeEmptyData();\n      }\n\n      if (!incoming) {\n        return existing;\n      }\n\n      var incomingEdges = incoming.edges ? incoming.edges.map(function (edge) {\n        if (isReference(edge = __assign({}, edge))) {\n          edge.cursor = readField(\"cursor\", edge);\n        }\n\n        return edge;\n      }) : [];\n\n      if (incoming.pageInfo) {\n        var pageInfo_1 = incoming.pageInfo;\n        var startCursor = pageInfo_1.startCursor,\n            endCursor = pageInfo_1.endCursor;\n        var firstEdge = incomingEdges[0];\n        var lastEdge = incomingEdges[incomingEdges.length - 1];\n\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n\n        var firstCursor = firstEdge && firstEdge.cursor;\n\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor\n            }\n          });\n        }\n\n        var lastCursor = lastEdge && lastEdge.cursor;\n\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor\n            }\n          });\n        }\n      }\n\n      var prefix = existing.edges;\n      var suffix = [];\n\n      if (args && args.after) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.after;\n        });\n\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n        }\n      } else if (args && args.before) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.before;\n        });\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        prefix = [];\n      }\n\n      var edges = __spreadArray(__spreadArray(__spreadArray([], prefix, true), incomingEdges, true), suffix, true);\n\n      var pageInfo = __assign(__assign({}, incoming.pageInfo), existing.pageInfo);\n\n      if (incoming.pageInfo) {\n        var _b = incoming.pageInfo,\n            hasPreviousPage = _b.hasPreviousPage,\n            hasNextPage = _b.hasNextPage,\n            startCursor = _b.startCursor,\n            endCursor = _b.endCursor,\n            extras = __rest_1(_b, [\"hasPreviousPage\", \"hasNextPage\", \"startCursor\", \"endCursor\"]);\n\n        Object.assign(pageInfo, extras);\n\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return __assign(__assign(__assign({}, getExtras(existing)), getExtras(incoming)), {\n        edges: edges,\n        pageInfo: pageInfo\n      });\n    }\n  };\n}\n\nvar getExtras = function (obj) {\n  return __rest(obj, notExtras);\n};\n\nvar notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData() {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\"\n    }\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,QAAT,EAAmBC,MAAM,IAAIC,QAA7B,EAAuCC,aAAvC,QAA4D,OAA5D;AACA,SAASF,MAAT,QAAuB,OAAvB;AACA,SAASG,SAAT,QAA0B,wBAA1B;AACA,OAAO,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;AACtC,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,WAAO,GAAG,KAAV;AAAkB;;AAC5C,SAAO;AACHA,WAAO,EAAEA,OADN;AAEHC,SAAK,EAAE,UAAUC,QAAV,EAAoBC,QAApB,EAA8B;AACjC,aAAOD,QAAQ,GAAGL,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKK,QAAL,EAAe,IAAf,CAAd,EAAoCC,QAApC,EAA8C,IAA9C,CAAhB,GAAsEA,QAArF;AACH;AAJE,GAAP;AAMH;AACD,OAAO,SAASC,qBAAT,CAA+BJ,OAA/B,EAAwC;AAC3C,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,WAAO,GAAG,KAAV;AAAkB;;AAC5C,SAAO;AACHA,WAAO,EAAEA,OADN;AAEHC,SAAK,EAAE,UAAUC,QAAV,EAAoBC,QAApB,EAA8BE,EAA9B,EAAkC;AACrC,UAAIC,IAAI,GAAGD,EAAE,CAACC,IAAd;AACA,UAAIC,MAAM,GAAGL,QAAQ,GAAGA,QAAQ,CAACM,KAAT,CAAe,CAAf,CAAH,GAAuB,EAA5C;;AACA,UAAIL,QAAJ,EAAc;AACV,YAAIG,IAAJ,EAAU;AACN,cAAIG,EAAE,GAAGH,IAAI,CAACI,MAAd;AAAA,cAAsBA,MAAM,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAAnD;;AACA,eAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,QAAQ,CAACS,MAA7B,EAAqC,EAAED,CAAvC,EAA0C;AACtCJ,kBAAM,CAACG,MAAM,GAAGC,CAAV,CAAN,GAAqBR,QAAQ,CAACQ,CAAD,CAA7B;AACH;AACJ,SALD,MAMK;AACDJ,gBAAM,CAACM,IAAP,CAAYC,KAAZ,CAAkBP,MAAlB,EAA0BJ,QAA1B;AACH;AACJ;;AACD,aAAOI,MAAP;AACH;AAjBE,GAAP;AAmBH;AACD,OAAO,SAASQ,oBAAT,CAA8Bf,OAA9B,EAAuC;AAC1C,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,WAAO,GAAG,KAAV;AAAkB;;AAC5C,SAAO;AACHA,WAAO,EAAEA,OADN;AAEHgB,QAAI,EAAE,UAAUd,QAAV,EAAoBG,EAApB,EAAwB;AAC1B,UAAIY,OAAO,GAAGZ,EAAE,CAACY,OAAjB;AAAA,UAA0BC,SAAS,GAAGb,EAAE,CAACa,SAAzC;AACA,UAAI,CAAChB,QAAL,EACI,OAAOA,QAAP;AACJ,UAAIiB,KAAK,GAAG,EAAZ;AACA,UAAIC,eAAe,GAAG,EAAtB;AACA,UAAIC,cAAc,GAAG,EAArB;AACAnB,cAAQ,CAACiB,KAAT,CAAeG,OAAf,CAAuB,UAAUC,IAAV,EAAgB;AACnC,YAAIN,OAAO,CAACC,SAAS,CAAC,MAAD,EAASK,IAAT,CAAV,CAAX,EAAsC;AAClCJ,eAAK,CAACN,IAAN,CAAWU,IAAX;;AACA,cAAIA,IAAI,CAACC,MAAT,EAAiB;AACbJ,2BAAe,GAAGA,eAAe,IAAIG,IAAI,CAACC,MAAxB,IAAkC,EAApD;AACAH,0BAAc,GAAGE,IAAI,CAACC,MAAL,IAAeH,cAAhC;AACH;AACJ;AACJ,OARD;;AASA,UAAIZ,EAAE,GAAGP,QAAQ,CAACuB,QAAT,IAAqB,EAA9B;AAAA,UAAkCC,WAAW,GAAGjB,EAAE,CAACiB,WAAnD;AAAA,UAAgEC,SAAS,GAAGlB,EAAE,CAACkB,SAA/E;;AACA,aAAOjC,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKkC,SAAS,CAAC1B,QAAD,CAAd,CAAT,EAAoC;AAAEiB,aAAK,EAAEA,KAAT;AAAgBM,gBAAQ,EAAE/B,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKQ,QAAQ,CAACuB,QAAd,CAAT,EAAkC;AAAEC,qBAAW,EAAEA,WAAW,IAAIN,eAA9B;AAA+CO,mBAAS,EAAEA,SAAS,IAAIN;AAAvE,SAAlC;AAAlC,OAApC,CAAf;AACH,KApBE;AAqBHpB,SAAK,EAAE,UAAUC,QAAV,EAAoBC,QAApB,EAA8BE,EAA9B,EAAkC;AACrC,UAAIC,IAAI,GAAGD,EAAE,CAACC,IAAd;AAAA,UAAoBuB,WAAW,GAAGxB,EAAE,CAACwB,WAArC;AAAA,UAAkDX,SAAS,GAAGb,EAAE,CAACa,SAAjE;;AACA,UAAI,CAAChB,QAAL,EAAe;AACXA,gBAAQ,GAAG4B,aAAa,EAAxB;AACH;;AACD,UAAI,CAAC3B,QAAL,EAAe;AACX,eAAOD,QAAP;AACH;;AACD,UAAI6B,aAAa,GAAG5B,QAAQ,CAACgB,KAAT,GAAiBhB,QAAQ,CAACgB,KAAT,CAAea,GAAf,CAAmB,UAAUT,IAAV,EAAgB;AACpE,YAAIM,WAAW,CAACN,IAAI,GAAG7B,QAAQ,CAAC,EAAD,EAAK6B,IAAL,CAAhB,CAAf,EAA4C;AACxCA,cAAI,CAACC,MAAL,GAAcN,SAAS,CAAC,QAAD,EAAWK,IAAX,CAAvB;AACH;;AACD,eAAOA,IAAP;AACH,OALoC,CAAjB,GAKf,EALL;;AAMA,UAAIpB,QAAQ,CAACsB,QAAb,EAAuB;AACnB,YAAIQ,UAAU,GAAG9B,QAAQ,CAACsB,QAA1B;AACA,YAAIC,WAAW,GAAGO,UAAU,CAACP,WAA7B;AAAA,YAA0CC,SAAS,GAAGM,UAAU,CAACN,SAAjE;AACA,YAAIO,SAAS,GAAGH,aAAa,CAAC,CAAD,CAA7B;AACA,YAAII,QAAQ,GAAGJ,aAAa,CAACA,aAAa,CAACnB,MAAd,GAAuB,CAAxB,CAA5B;;AACA,YAAIsB,SAAS,IAAIR,WAAjB,EAA8B;AAC1BQ,mBAAS,CAACV,MAAV,GAAmBE,WAAnB;AACH;;AACD,YAAIS,QAAQ,IAAIR,SAAhB,EAA2B;AACvBQ,kBAAQ,CAACX,MAAT,GAAkBG,SAAlB;AACH;;AACD,YAAIS,WAAW,GAAGF,SAAS,IAAIA,SAAS,CAACV,MAAzC;;AACA,YAAIY,WAAW,IAAI,CAACV,WAApB,EAAiC;AAC7BvB,kBAAQ,GAAGL,SAAS,CAACK,QAAD,EAAW;AAC3BsB,oBAAQ,EAAE;AACNC,yBAAW,EAAEU;AADP;AADiB,WAAX,CAApB;AAKH;;AACD,YAAIC,UAAU,GAAGF,QAAQ,IAAIA,QAAQ,CAACX,MAAtC;;AACA,YAAIa,UAAU,IAAI,CAACV,SAAnB,EAA8B;AAC1BxB,kBAAQ,GAAGL,SAAS,CAACK,QAAD,EAAW;AAC3BsB,oBAAQ,EAAE;AACNE,uBAAS,EAAEU;AADL;AADiB,WAAX,CAApB;AAKH;AACJ;;AACD,UAAIC,MAAM,GAAGpC,QAAQ,CAACiB,KAAtB;AACA,UAAIoB,MAAM,GAAG,EAAb;;AACA,UAAIjC,IAAI,IAAIA,IAAI,CAACkC,KAAjB,EAAwB;AACpB,YAAIC,KAAK,GAAGH,MAAM,CAACI,SAAP,CAAiB,UAAUnB,IAAV,EAAgB;AAAE,iBAAOA,IAAI,CAACC,MAAL,KAAgBlB,IAAI,CAACkC,KAA5B;AAAoC,SAAvE,CAAZ;;AACA,YAAIC,KAAK,IAAI,CAAb,EAAgB;AACZH,gBAAM,GAAGA,MAAM,CAAC9B,KAAP,CAAa,CAAb,EAAgBiC,KAAK,GAAG,CAAxB,CAAT;AACH;AACJ,OALD,MAMK,IAAInC,IAAI,IAAIA,IAAI,CAACqC,MAAjB,EAAyB;AAC1B,YAAIF,KAAK,GAAGH,MAAM,CAACI,SAAP,CAAiB,UAAUnB,IAAV,EAAgB;AAAE,iBAAOA,IAAI,CAACC,MAAL,KAAgBlB,IAAI,CAACqC,MAA5B;AAAqC,SAAxE,CAAZ;AACAJ,cAAM,GAAGE,KAAK,GAAG,CAAR,GAAYH,MAAZ,GAAqBA,MAAM,CAAC9B,KAAP,CAAaiC,KAAb,CAA9B;AACAH,cAAM,GAAG,EAAT;AACH,OAJI,MAKA,IAAInC,QAAQ,CAACgB,KAAb,EAAoB;AACrBmB,cAAM,GAAG,EAAT;AACH;;AACD,UAAInB,KAAK,GAAGtB,aAAa,CAACA,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyC,MAAL,EAAa,IAAb,CAAd,EAAkCP,aAAlC,EAAiD,IAAjD,CAAd,EAAsEQ,MAAtE,EAA8E,IAA9E,CAAzB;;AACA,UAAId,QAAQ,GAAG/B,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKS,QAAQ,CAACsB,QAAd,CAAT,EAAkCvB,QAAQ,CAACuB,QAA3C,CAAvB;;AACA,UAAItB,QAAQ,CAACsB,QAAb,EAAuB;AACnB,YAAIhB,EAAE,GAAGN,QAAQ,CAACsB,QAAlB;AAAA,YAA4BmB,eAAe,GAAGnC,EAAE,CAACmC,eAAjD;AAAA,YAAkEC,WAAW,GAAGpC,EAAE,CAACoC,WAAnF;AAAA,YAAgGnB,WAAW,GAAGjB,EAAE,CAACiB,WAAjH;AAAA,YAA8HC,SAAS,GAAGlB,EAAE,CAACkB,SAA7I;AAAA,YAAwJmB,MAAM,GAAGlD,QAAQ,CAACa,EAAD,EAAK,CAAC,iBAAD,EAAoB,aAApB,EAAmC,aAAnC,EAAkD,WAAlD,CAAL,CAAzK;;AACAsC,cAAM,CAACC,MAAP,CAAcvB,QAAd,EAAwBqB,MAAxB;;AACA,YAAI,CAACR,MAAM,CAAC1B,MAAZ,EAAoB;AAChB,cAAI,KAAK,CAAL,KAAWgC,eAAf,EACInB,QAAQ,CAACmB,eAAT,GAA2BA,eAA3B;AACJ,cAAI,KAAK,CAAL,KAAWlB,WAAf,EACID,QAAQ,CAACC,WAAT,GAAuBA,WAAvB;AACP;;AACD,YAAI,CAACa,MAAM,CAAC3B,MAAZ,EAAoB;AAChB,cAAI,KAAK,CAAL,KAAWiC,WAAf,EACIpB,QAAQ,CAACoB,WAAT,GAAuBA,WAAvB;AACJ,cAAI,KAAK,CAAL,KAAWlB,SAAf,EACIF,QAAQ,CAACE,SAAT,GAAqBA,SAArB;AACP;AACJ;;AACD,aAAOjC,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKkC,SAAS,CAAC1B,QAAD,CAAd,CAAT,EAAoC0B,SAAS,CAACzB,QAAD,CAA7C,CAAT,EAAmE;AAAEgB,aAAK,EAAEA,KAAT;AAAgBM,gBAAQ,EAAEA;AAA1B,OAAnE,CAAf;AACH;AAlGE,GAAP;AAoGH;;AACD,IAAIG,SAAS,GAAG,UAAUqB,GAAV,EAAe;AAAE,SAAOtD,MAAM,CAACsD,GAAD,EAAMC,SAAN,CAAb;AAAgC,CAAjE;;AACA,IAAIA,SAAS,GAAG,CAAC,OAAD,EAAU,UAAV,CAAhB;;AACA,SAASpB,aAAT,GAAyB;AACrB,SAAO;AACHX,SAAK,EAAE,EADJ;AAEHM,YAAQ,EAAE;AACNmB,qBAAe,EAAE,KADX;AAENC,iBAAW,EAAE,IAFP;AAGNnB,iBAAW,EAAE,EAHP;AAINC,eAAS,EAAE;AAJL;AAFP,GAAP;AASH","names":["__assign","__rest","__rest_1","__spreadArray","mergeDeep","concatPagination","keyArgs","merge","existing","incoming","offsetLimitPagination","_a","args","merged","slice","_b","offset","i","length","push","apply","relayStylePagination","read","canRead","readField","edges","firstEdgeCursor","lastEdgeCursor","forEach","edge","cursor","pageInfo","startCursor","endCursor","getExtras","isReference","makeEmptyData","incomingEdges","map","pageInfo_1","firstEdge","lastEdge","firstCursor","lastCursor","prefix","suffix","after","index","findIndex","before","hasPreviousPage","hasNextPage","extras","Object","assign","obj","notExtras"],"sources":["C:/Users/jamesi/Desktop/Repos/full-stack-open/part8/library-frontend/node_modules/@apollo/client/utilities/policies/pagination.js"],"sourcesContent":["import { __assign, __rest as __rest_1, __spreadArray } from \"tslib\";\nimport { __rest } from \"tslib\";\nimport { mergeDeep } from \"../common/mergeDeep.js\";\nexport function concatPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming) {\n            return existing ? __spreadArray(__spreadArray([], existing, true), incoming, true) : incoming;\n        },\n    };\n}\nexport function offsetLimitPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming, _a) {\n            var args = _a.args;\n            var merged = existing ? existing.slice(0) : [];\n            if (incoming) {\n                if (args) {\n                    var _b = args.offset, offset = _b === void 0 ? 0 : _b;\n                    for (var i = 0; i < incoming.length; ++i) {\n                        merged[offset + i] = incoming[i];\n                    }\n                }\n                else {\n                    merged.push.apply(merged, incoming);\n                }\n            }\n            return merged;\n        },\n    };\n}\nexport function relayStylePagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        read: function (existing, _a) {\n            var canRead = _a.canRead, readField = _a.readField;\n            if (!existing)\n                return existing;\n            var edges = [];\n            var firstEdgeCursor = \"\";\n            var lastEdgeCursor = \"\";\n            existing.edges.forEach(function (edge) {\n                if (canRead(readField(\"node\", edge))) {\n                    edges.push(edge);\n                    if (edge.cursor) {\n                        firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n                        lastEdgeCursor = edge.cursor || lastEdgeCursor;\n                    }\n                }\n            });\n            var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;\n            return __assign(__assign({}, getExtras(existing)), { edges: edges, pageInfo: __assign(__assign({}, existing.pageInfo), { startCursor: startCursor || firstEdgeCursor, endCursor: endCursor || lastEdgeCursor }) });\n        },\n        merge: function (existing, incoming, _a) {\n            var args = _a.args, isReference = _a.isReference, readField = _a.readField;\n            if (!existing) {\n                existing = makeEmptyData();\n            }\n            if (!incoming) {\n                return existing;\n            }\n            var incomingEdges = incoming.edges ? incoming.edges.map(function (edge) {\n                if (isReference(edge = __assign({}, edge))) {\n                    edge.cursor = readField(\"cursor\", edge);\n                }\n                return edge;\n            }) : [];\n            if (incoming.pageInfo) {\n                var pageInfo_1 = incoming.pageInfo;\n                var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;\n                var firstEdge = incomingEdges[0];\n                var lastEdge = incomingEdges[incomingEdges.length - 1];\n                if (firstEdge && startCursor) {\n                    firstEdge.cursor = startCursor;\n                }\n                if (lastEdge && endCursor) {\n                    lastEdge.cursor = endCursor;\n                }\n                var firstCursor = firstEdge && firstEdge.cursor;\n                if (firstCursor && !startCursor) {\n                    incoming = mergeDeep(incoming, {\n                        pageInfo: {\n                            startCursor: firstCursor,\n                        },\n                    });\n                }\n                var lastCursor = lastEdge && lastEdge.cursor;\n                if (lastCursor && !endCursor) {\n                    incoming = mergeDeep(incoming, {\n                        pageInfo: {\n                            endCursor: lastCursor,\n                        },\n                    });\n                }\n            }\n            var prefix = existing.edges;\n            var suffix = [];\n            if (args && args.after) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.after; });\n                if (index >= 0) {\n                    prefix = prefix.slice(0, index + 1);\n                }\n            }\n            else if (args && args.before) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.before; });\n                suffix = index < 0 ? prefix : prefix.slice(index);\n                prefix = [];\n            }\n            else if (incoming.edges) {\n                prefix = [];\n            }\n            var edges = __spreadArray(__spreadArray(__spreadArray([], prefix, true), incomingEdges, true), suffix, true);\n            var pageInfo = __assign(__assign({}, incoming.pageInfo), existing.pageInfo);\n            if (incoming.pageInfo) {\n                var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = __rest_1(_b, [\"hasPreviousPage\", \"hasNextPage\", \"startCursor\", \"endCursor\"]);\n                Object.assign(pageInfo, extras);\n                if (!prefix.length) {\n                    if (void 0 !== hasPreviousPage)\n                        pageInfo.hasPreviousPage = hasPreviousPage;\n                    if (void 0 !== startCursor)\n                        pageInfo.startCursor = startCursor;\n                }\n                if (!suffix.length) {\n                    if (void 0 !== hasNextPage)\n                        pageInfo.hasNextPage = hasNextPage;\n                    if (void 0 !== endCursor)\n                        pageInfo.endCursor = endCursor;\n                }\n            }\n            return __assign(__assign(__assign({}, getExtras(existing)), getExtras(incoming)), { edges: edges, pageInfo: pageInfo });\n        },\n    };\n}\nvar getExtras = function (obj) { return __rest(obj, notExtras); };\nvar notExtras = [\"edges\", \"pageInfo\"];\nfunction makeEmptyData() {\n    return {\n        edges: [],\n        pageInfo: {\n            hasPreviousPage: false,\n            hasNextPage: true,\n            startCursor: \"\",\n            endCursor: \"\",\n        },\n    };\n}\n"]},"metadata":{},"sourceType":"module"}