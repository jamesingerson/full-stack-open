{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { wrap } from 'optimism';\nimport { isField, resultKeyNameFromField, isReference, makeReference, createFragmentMap, shouldInclude, addTypenameToDocument, getDefaultValues, getFragmentDefinitions, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { getTypenameFromStoreObject, isArray, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { canonicalStringify, ObjectCanon } from \"./object-canon.js\";\n;\n\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context, options.context.canonizeResults];\n}\n\nvar StoreReader = function () {\n  function StoreReader(config) {\n    var _this = this;\n\n    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config)\n    });\n    this.canon = config.canon || new ObjectCanon();\n    this.executeSelectionSet = wrap(function (options) {\n      var _a;\n\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options);\n      peekArgs[3] = !canonizeResults;\n\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n\n      if (other) {\n        if (canonizeResults) {\n          return __assign(__assign({}, other), {\n            result: _this.canon.admit(other.result)\n          });\n        }\n\n        return other;\n      }\n\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      keyArgs: execSelectionSetKeyArgs,\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n            array = _a.array,\n            context = _a.context;\n\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new ObjectCanon();\n  };\n\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n        query = _a.query,\n        _b = _a.rootId,\n        rootId = _b === void 0 ? 'ROOT_QUERY' : _b,\n        variables = _a.variables,\n        _c = _a.returnPartialData,\n        returnPartialData = _c === void 0 ? true : _c,\n        _d = _a.canonizeResults,\n        canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var rootRef = makeReference(rootId);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: canonicalStringify(variables),\n        canonizeResults: canonizeResults,\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query))\n      }\n    });\n    var missing;\n\n    if (execResult.missing) {\n      missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing: missing\n    };\n  };\n\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));\n\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n\n    var selectionSet = _a.selectionSet,\n        objectOrReference = _a.objectOrReference,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n      };\n    }\n\n    var variables = context.variables,\n        policies = context.policies,\n        store = context.store;\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    var objectsToMerge = [];\n    var missing;\n    var missingMerger = new DeepMerger();\n\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n\n    function handleMissing(result, resultName) {\n      var _a;\n\n      if (result.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n      }\n\n      return result.result;\n    }\n\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a, _b;\n\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a));\n          }\n        } else if (isArray(fieldValue)) {\n          fieldValue = handleMissing(_this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef: enclosingRef,\n            context: context\n          }), resultName);\n        } else if (!selection.selectionSet) {\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }), resultName);\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var result = mergeDeepArray(objectsToMerge);\n    var finalResult = {\n      result: result,\n      missing: missing\n    };\n    var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);\n\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  };\n\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n\n    var field = _a.field,\n        array = _a.array,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n    var missing;\n    var missingMerger = new DeepMerger();\n\n    function handleMissing(childResult, i) {\n      var _a;\n\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n      }\n\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map(function (item, i) {\n      if (item === null) {\n        return null;\n      }\n\n      if (isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      }\n\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n\n  return StoreReader;\n}();\n\nexport { StoreReader };\n\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, function (_, value) {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\n\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (isNonNullObject(value)) {\n        __DEV__ ? invariant(!isReference(value), \"Missing selection set for object of type \".concat(getTypenameFromStoreObject(store, value), \" returned for query field \").concat(field.name.value)) : invariant(!isReference(value), 5);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["__assign","invariant","wrap","isField","resultKeyNameFromField","isReference","makeReference","createFragmentMap","shouldInclude","addTypenameToDocument","getDefaultValues","getFragmentDefinitions","getMainDefinition","getQueryDefinition","getFragmentFromSelection","maybeDeepFreeze","mergeDeepArray","DeepMerger","isNonNullObject","canUseWeakMap","compact","maybeDependOnExistenceOfEntity","supportsResultCaching","getTypenameFromStoreObject","isArray","shouldCanonizeResults","MissingFieldError","canonicalStringify","ObjectCanon","execSelectionSetKeyArgs","options","selectionSet","objectOrReference","context","canonizeResults","StoreReader","config","_this","knownResults","WeakMap","Map","addTypename","canon","executeSelectionSet","_a","peekArgs","other","peek","apply","result","admit","store","enclosingRef","__ref","execSelectionSetImpl","max","resultCacheMaxSize","keyArgs","makeCacheKey","parent","varString","executeSubSelectedArray","execSubSelectedArrayImpl","field","array","prototype","resetCanon","diffQueryAgainstStore","query","_b","rootId","variables","_c","returnPartialData","_d","policies","cache","rootRef","execResult","fragmentMap","missing","firstMissing","complete","isFresh","get","latest","isKnown","rootTypenamesById","has","empty","concat","typename","getFieldValue","objectsToMerge","missingMerger","rootIdsByTypename","push","__typename","handleMissing","resultName","merge","workSet","Set","selections","forEach","selection","fieldValue","readField","fieldName","name","value","from","added","JSON","stringify","pass","fragment","fragmentMatches","add","finalResult","frozen","set","childResult","i","filter","canRead","map","item","__DEV__","assertSelectionSetForIdValue","tree","_","workSet_1","Object","values"],"sources":["C:/Users/jamesi/Desktop/Repos/full-stack-open/part8/library-frontend/node_modules/@apollo/client/cache/inmemory/readFromStore.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { wrap } from 'optimism';\nimport { isField, resultKeyNameFromField, isReference, makeReference, createFragmentMap, shouldInclude, addTypenameToDocument, getDefaultValues, getFragmentDefinitions, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { getTypenameFromStoreObject, isArray, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { canonicalStringify, ObjectCanon } from \"./object-canon.js\";\n;\nfunction execSelectionSetKeyArgs(options) {\n    return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n        options.context.canonizeResults,\n    ];\n}\nvar StoreReader = (function () {\n    function StoreReader(config) {\n        var _this = this;\n        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n        this.config = compact(config, {\n            addTypename: config.addTypename !== false,\n            canonizeResults: shouldCanonizeResults(config),\n        });\n        this.canon = config.canon || new ObjectCanon;\n        this.executeSelectionSet = wrap(function (options) {\n            var _a;\n            var canonizeResults = options.context.canonizeResults;\n            var peekArgs = execSelectionSetKeyArgs(options);\n            peekArgs[3] = !canonizeResults;\n            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n            if (other) {\n                if (canonizeResults) {\n                    return __assign(__assign({}, other), { result: _this.canon.admit(other.result) });\n                }\n                return other;\n            }\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return _this.execSelectionSetImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            keyArgs: execSelectionSetKeyArgs,\n            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n                }\n            }\n        });\n        this.executeSubSelectedArray = wrap(function (options) {\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return _this.execSubSelectedArrayImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, context = _a.context;\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(field, array, context.varString);\n                }\n            }\n        });\n    }\n    StoreReader.prototype.resetCanon = function () {\n        this.canon = new ObjectCanon;\n    };\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? 'ROOT_QUERY' : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n        var policies = this.config.cache.policies;\n        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n        var rootRef = makeReference(rootId);\n        var execResult = this.executeSelectionSet({\n            selectionSet: getMainDefinition(query).selectionSet,\n            objectOrReference: rootRef,\n            enclosingRef: rootRef,\n            context: {\n                store: store,\n                query: query,\n                policies: policies,\n                variables: variables,\n                varString: canonicalStringify(variables),\n                canonizeResults: canonizeResults,\n                fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n            },\n        });\n        var missing;\n        if (execResult.missing) {\n            missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n            if (!returnPartialData) {\n                throw missing[0];\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !missing,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n        if (supportsResultCaching(context.store) &&\n            this.knownResults.get(result) === selectionSet) {\n            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));\n            if (latest && result === latest.result) {\n                return true;\n            }\n        }\n        return false;\n    };\n    StoreReader.prototype.execSelectionSetImpl = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\n        if (isReference(objectOrReference) &&\n            !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n            !context.store.has(objectOrReference.__ref)) {\n            return {\n                result: this.canon.empty,\n                missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\"),\n            };\n        }\n        var variables = context.variables, policies = context.policies, store = context.store;\n        var typename = store.getFieldValue(objectOrReference, \"__typename\");\n        var objectsToMerge = [];\n        var missing;\n        var missingMerger = new DeepMerger();\n        if (this.config.addTypename &&\n            typeof typename === \"string\" &&\n            !policies.rootIdsByTypename[typename]) {\n            objectsToMerge.push({ __typename: typename });\n        }\n        function handleMissing(result, resultName) {\n            var _a;\n            if (result.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n            }\n            return result.result;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function (selection) {\n            var _a, _b;\n            if (!shouldInclude(selection, variables))\n                return;\n            if (isField(selection)) {\n                var fieldValue = policies.readField({\n                    fieldName: selection.name.value,\n                    field: selection,\n                    variables: context.variables,\n                    from: objectOrReference,\n                }, context);\n                var resultName = resultKeyNameFromField(selection);\n                if (fieldValue === void 0) {\n                    if (!addTypenameToDocument.added(selection)) {\n                        missing = missingMerger.merge(missing, (_a = {},\n                            _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference)\n                                ? objectOrReference.__ref + \" object\"\n                                : \"object \" + JSON.stringify(objectOrReference, null, 2)),\n                            _a));\n                    }\n                }\n                else if (isArray(fieldValue)) {\n                    fieldValue = handleMissing(_this.executeSubSelectedArray({\n                        field: selection,\n                        array: fieldValue,\n                        enclosingRef: enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                else if (!selection.selectionSet) {\n                    if (context.canonizeResults) {\n                        fieldValue = _this.canon.pass(fieldValue);\n                    }\n                }\n                else if (fieldValue != null) {\n                    fieldValue = handleMissing(_this.executeSelectionSet({\n                        selectionSet: selection.selectionSet,\n                        objectOrReference: fieldValue,\n                        enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                if (fieldValue !== void 0) {\n                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        var result = mergeDeepArray(objectsToMerge);\n        var finalResult = { result: result, missing: missing };\n        var frozen = context.canonizeResults\n            ? this.canon.admit(finalResult)\n            : maybeDeepFreeze(finalResult);\n        if (frozen.result) {\n            this.knownResults.set(frozen.result, selectionSet);\n        }\n        return frozen;\n    };\n    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\n        var missing;\n        var missingMerger = new DeepMerger();\n        function handleMissing(childResult, i) {\n            var _a;\n            if (childResult.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n            }\n            return childResult.result;\n        }\n        if (field.selectionSet) {\n            array = array.filter(context.store.canRead);\n        }\n        array = array.map(function (item, i) {\n            if (item === null) {\n                return null;\n            }\n            if (isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    enclosingRef: enclosingRef,\n                    context: context,\n                }), i);\n            }\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    objectOrReference: item,\n                    enclosingRef: isReference(item) ? item : enclosingRef,\n                    context: context,\n                }), i);\n            }\n            if (__DEV__) {\n                assertSelectionSetForIdValue(context.store, field, item);\n            }\n            return item;\n        });\n        return {\n            result: context.canonizeResults ? this.canon.admit(array) : array,\n            missing: missing,\n        };\n    };\n    return StoreReader;\n}());\nexport { StoreReader };\nfunction firstMissing(tree) {\n    try {\n        JSON.stringify(tree, function (_, value) {\n            if (typeof value === \"string\")\n                throw value;\n            return value;\n        });\n    }\n    catch (result) {\n        return result;\n    }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n    if (!field.selectionSet) {\n        var workSet_1 = new Set([fieldValue]);\n        workSet_1.forEach(function (value) {\n            if (isNonNullObject(value)) {\n                __DEV__ ? invariant(!isReference(value), \"Missing selection set for object of type \".concat(getTypenameFromStoreObject(store, value), \" returned for query field \").concat(field.name.value)) : invariant(!isReference(value), 5);\n                Object.values(value).forEach(workSet_1.add, workSet_1);\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}